
project external/chromium_org/
diff --git a/external/chromium_org/android_webview/browser/in_process_view_renderer.cc b/external/chromium_org/android_webview/browser/in_process_view_renderer.cc
index bcfa3b9..bb26eb0 100644
--- a/external/chromium_org/android_webview/browser/in_process_view_renderer.cc
+++ b/external/chromium_org/android_webview/browser/in_process_view_renderer.cc
@@ -128,8 +128,13 @@ class ScopedPixelAccess {
 };
 
 bool HardwareEnabled() {
+// HACK: JAVA_HWC has problems with GL image upload which can lead to system crash
+#ifdef JAVA_HWC
+  static bool g_hw_enabled = false;
+#else
   static bool g_hw_enabled = !CommandLine::ForCurrentProcess()->HasSwitch(
       switches::kDisableWebViewGLMode);
+#endif
   return g_hw_enabled;
 }
 

project frameworks/av/
diff --git a/frameworks/av/media/libstagefright/OMXCodec.cpp b/frameworks/av/media/libstagefright/OMXCodec.cpp
index a75c8f9..d905c11 100644
--- a/frameworks/av/media/libstagefright/OMXCodec.cpp
+++ b/frameworks/av/media/libstagefright/OMXCodec.cpp
@@ -930,6 +930,18 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
     if (meta->findInt32(kKeyMaxInputSize, &maxInputSize)) {
         setMinBufferSize(kPortIndexInput, (OMX_U32)maxInputSize);
     }
+// Java's OMX fail to set a reasonable default size from width and height
+#ifdef JAVA_HWC
+    else if (!strncmp(mComponentName, "OMX.BRCM.vc4.decoder.", 21)) {
+        int32_t width;
+        int32_t height;
+        if (meta->findInt32(kKeyWidth, &width) && meta->findInt32(kKeyHeight, &height)) {
+            setMinBufferSize(kPortIndexInput, (width * height * 3) / 2);
+        } else {
+            ALOGE("Failed to set min buffer size");
+        }
+    }
+#endif
 
     initOutputFormat(meta);
 

project frameworks/native/
diff --git a/frameworks/native/libs/binder/Parcel.cpp b/frameworks/native/libs/binder/Parcel.cpp
index db9e0a1..bb6856c 100644
--- a/frameworks/native/libs/binder/Parcel.cpp
+++ b/frameworks/native/libs/binder/Parcel.cpp
@@ -819,6 +819,12 @@ status_t Parcel::writeBlob(size_t len, WritableBlob* outBlob)
     return status;
 }
 
+extern "C" status_t _ZN7android6Parcel5writeERKNS0_26FlattenableHelperInterfaceE(void *parcel, void *val);
+
+extern "C" status_t _ZN7android6Parcel5writeERKNS_11FlattenableE(void *parcel, void *val) {
+    return _ZN7android6Parcel5writeERKNS0_26FlattenableHelperInterfaceE(parcel, val);
+}
+
 status_t Parcel::write(const FlattenableHelperInterface& val)
 {
     status_t err;
@@ -1197,6 +1203,12 @@ status_t Parcel::readBlob(size_t len, ReadableBlob* outBlob) const
     return NO_ERROR;
 }
 
+extern "C" status_t _ZNK7android6Parcel4readERNS0_26FlattenableHelperInterfaceE(void *parcel, void *val);
+
+extern "C" status_t _ZNK7android6Parcel4readERNS_11FlattenableE(void *parcel, void *val) {
+    return _ZNK7android6Parcel4readERNS0_26FlattenableHelperInterfaceE(parcel, val);
+}
+
 status_t Parcel::read(FlattenableHelperInterface& val) const
 {
     // size
diff --git a/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp b/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
index dd6865d..0e9c24b 100644
--- a/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
+++ b/frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp
@@ -1234,13 +1234,18 @@ public:
         //getLayer()->compositionType = HWC_FRAMEBUFFER;
     }
     virtual void setPlaneAlpha(uint8_t alpha) {
+// JAVA_HWC does not respect planeAlpha despite being v1.2
+#ifndef JAVA_HWC
         if (hwcHasApiVersion(mHwc, HWC_DEVICE_API_VERSION_1_2)) {
             getLayer()->planeAlpha = alpha;
         } else {
+#endif
             if (alpha < 0xFF) {
                 getLayer()->flags |= HWC_SKIP_LAYER;
             }
+#ifndef JAVA_HWC
         }
+#endif
     }
     virtual void setDefaultState() {
         hwc_layer_1_t* const l = getLayer();
diff --git a/frameworks/native/services/surfaceflinger/Layer.cpp b/frameworks/native/services/surfaceflinger/Layer.cpp
index 4def60a..5e30232 100644
--- a/frameworks/native/services/surfaceflinger/Layer.cpp
+++ b/frameworks/native/services/surfaceflinger/Layer.cpp
@@ -1260,6 +1260,8 @@ uint32_t Layer::getEffectiveUsage(uint32_t usage) const
 
 void Layer::updateTransformHint(const sp<const DisplayDevice>& hw) {
     uint32_t orientation = 0;
+// JAVA_HWC has display problem in landscape mode when transform is used
+#ifndef JAVA_HWC
     if (!mFlinger->mDebugDisableTransformHint) {
         // The transform hint is used to improve performance, but we can
         // only have a single transform hint, it cannot
@@ -1270,6 +1272,7 @@ void Layer::updateTransformHint(const sp<const DisplayDevice>& hw) {
             orientation = 0;
         }
     }
+#endif
     mSurfaceFlingerConsumer->setTransformHint(orientation);
     mTransformHint = orientation;
 }
diff --git a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
index e7c4716..7f6b0a9 100644
--- a/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
+++ b/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
@@ -1162,6 +1162,7 @@ void SurfaceFlinger::setUpHWComposer() {
             sp<const DisplayDevice> hw(mDisplays[dpy]);
             const int32_t id = hw->getHwcDisplayId();
             if (id >= 0) {
+#ifdef QCOM_HARDWARE
                 // Get the layers in the current drawying state
                 const LayerVector& layers(mDrawingState.layersSortedByZ);
                 bool freezeSurfacePresent = false;
@@ -1181,6 +1182,7 @@ void SurfaceFlinger::setUpHWComposer() {
                         }
                     }
                 }
+#endif
 
                 const Vector< sp<Layer> >& currentLayers(
                     hw->getVisibleLayersSortedByZ());
@@ -1194,6 +1196,7 @@ void SurfaceFlinger::setUpHWComposer() {
                      */
                     const sp<Layer>& layer(currentLayers[i]);
                     layer->setPerFrameData(hw, *cur);
+#ifdef QCOM_HARDWARE
                     if(freezeSurfacePresent) {
                         // if freezeSurfacePresent, set ANIMATING flag
                         cur->setAnimating(true);
@@ -1218,6 +1221,7 @@ void SurfaceFlinger::setUpHWComposer() {
                             lastSurfaceViewLayer = layer;
                         }
                     }
+#endif
                 }
             }
         }
